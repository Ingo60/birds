--- Evaluation of SKI-expressions
module birds.Eval where

import Data.TreeMap
import birds.Ski
import birds.Def

infixl 7 `<>`

{-- 
    Reduce a SKI expression according to the following rules:
    - A primitive expressions (I,K,S,V,C) reduces to itself
    - @I <> a@ reduces to @a@
    - @K <> x <> y@ reduces to @x@
    - @S <> x <> y <> z@  reduces to   @x <> z <> (y <> z)@
    - @a<>b@ reduces to reduced @c<>b@, where @c@ is the reduced @a@. 

    Note that, if we have a<>b, b is not reduced.

    The definition below is a bit complex, but we must avoid 
    stack overflows on deeply nested expressions like
    
    >   unflat (replicate 5000 I)
    
    The reduction algorithm trades stack space against heap space, by
    going down to the expression nested deepest on the left, while pushing
    the right elements to a list (like 'flat'). Once the innermost expression
    has been reduced, we have either a 'Var', a 'Const' or a basic combinator.
    
    If it is a basic combinator, then its effect on the argument list is 
    computed, and the process continues until we have an atom that connot 
    be applied to the list anymore. 
    
    For example 
    
    > II(KI)I                   
    > (((II)(KI))I)             II(KI)I
    > ((II)(KI))   [I]          II(KI)I
    > (II) [KI,I]               II(KI)I
    
    Only at this point do we see that we can reduce II:
    
    > I [KI, I]                 I(KI)I
    
    The I pops the first argument off the list and lets it operate on the tail.
    Now again, we have an expression of the form @a <> b@ on top:
    
    > (KI) [I]                  KII
    > K [I, I]                  KII
    
    Now K can operate on the list, by throwing the second element away and
    we continue to operate with the first I.
     
    > I []                      I
    -}
eval tree = evaluate tree false
evaluate tree eager = reduce []
    where
        -- reduce acc ex | traceLn ("reduce: " ++ show ex ++ "  " ++ show acc) = undefined
        
        -- Now the critical step to avoid too deeply nested left recursions.
        -- The expression b is saved for later, and we continue with the left hand side
        -- Since this is tail recursion, it will be a loop at runtime.
        reduce acc (App a b)                    = reduce (b:acc) a
        
        -- At this point, the leftmost expression of the original
        -- expression is not of the form @a<>b@ anymore and the arguments
        -- are in the accumulator.
        -- For example, when we had
        --  (S <> K <> x) <> a <> b
        -- we have now 
        --   reduce [K,x,a,b] S
        
        -- We do now apply the basic reduction rules to the stack. 
        -- a) reduction of a primitive
        reduce xs (P _ f)                       = case f xs of
            Left result -> result
            Right ys    -> reduce (tail ys) (head ys)
        -- b) reduction of a constructor
        reduce xs (c@C s)                       = case Tree.lookupS tree s of
            Nothing -> unflat (c:xs)         -- unknown constructor
            Just def -> reduce xs (Def.bird def)    
        -- At tis point, the expression is reduced.
        -- It is nether of the form (a <> b), nor is it a I,K or S
        -- that could operate on the list.
        -- We take the opportunity to optimize the arguments a bit, 
        -- without reducing them fully. For, if we did reduce them
        -- now, then evaluation of
        --  Yf,  where Y is the fixpoint operator Yf = f(Yf)
        -- would cause us to evaluate Yf again, which would result in
        -- f(Yf) and we had to reduce that Yf again and so on ad infinitum.
        reduce acc x                            = unflat (x:map f acc)
            where f = if eager then evaluate tree true else id


--- evaluate the innermost expression until it is not reducible anymore
step tree = reduce [] where
    reduce acc (App a b)                    = reduce (b:acc) a
    reduce xs (P _ f)                       = case f xs of
        Left result -> result
        Right ys    -> unflat ys
    reduce xs (c@C s) = case Tree.lookupS tree s of
            Nothing  -> unflat (c:xs)         -- unknown constructor
            Just def -> unflat (Def.bird def:xs)    
    reduce acc x                            = unflat (x:acc)
            


