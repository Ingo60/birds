--- The interpreter for *birds*, a small language on top of the SKI calculus
module birds.Main where

import Data.List hiding(insert, lookup, delete, union)
import Data.TreeMap
import birds.Ski
import birds.Def

data ConsoleReader = mutable native jline.ConsoleReader where
    native new :: () -> IO ConsoleReader throws IOException
    native setPrompt setDefaultPrompt :: ConsoleReader -> String -> IO ()
    native readLine  :: ConsoleReader -> IO (Maybe String) throws IOException
                      | ConsoleReader -> String -> IO (Maybe String) throws IOException

data Global = St {
        console  :: ConsoleReader,
        birds, last :: DefTree,
        dbpath :: String        -- where to save stuff
    }
            
main xs = do
        console <- ConsoleReader.new ()
        console.setPrompt "ski> "
        ref     <- IORef.new St{console,  
                                birds = Tree.empty,
                                last  = Tree.empty,
                                dbpath = if null xs then "birds.ski" else head xs}
        
        loadFile ref (head xs)
        
        mapM_ println [
            "",
            "Enter expressions or combinator definitions or help for a command list.",
            "Type CTRL-D to end this session.",
            "",
            ] 
        forever (interaction ref) 
                `catch` eof
                `catch` ioex
                `finally` println "See you again."
    where
        eof :: EOFException -> IO ()
        eof _ = print "Good bye. "
        ioex :: IOException -> IO ()
        ioex _ = print "Sorry, we had an IO exception. "


oneLine :: IORef Global -> String -> IO ()
oneLine ref s = do
    let (command, expr) = parseCommand s
    command ref expr 

loadFile :: IORef Global -> String -> IO ()
loadFile ref "" = ref.get >>= loadFile ref . Global.dbpath
loadFile ref fn = do
            rdr <- openReader fn
            rdr.getLines >>= mapM_ (oneLine ref)
            rdr.close
            stderr.println ("Loaded " ++ fn)
            IORef.modify Global.{dbpath = fn} ref
        `catch` notfound fn
    
notfound :: String -> FileNotFoundException -> IO ()
notfound fn _ = stderr.println ("Could not find " ++ fn)

saveFile :: IORef Global -> String -> IO ()
saveFile ref "" = ref.get >>= saveFile ref . Global.dbpath
saveFile ref fn = do
            pr <- openWriter fn
            state <- ref.get
            mapM_ (pr.println . show) ((map undef . deporder) state.birds)
            pr.close
            stderr.println ("Saved to " ++ fn)
            IORef.modify Global.{dbpath = fn} ref
        `catch` notfound fn
    where
        undef D{left,right} = C ":" <> left <> right

interaction :: IORef Global -> IO ()
interaction ref = do
    state <- ref.get 
    line <- ConsoleReader.readLine state.console
    reply <- getReply ref line
    oneLine ref reply

getLast :: IORef Global -> IO SKI
getLast ref =  ref.get 
    >>= return . maybe I Def.bird . flip Tree.lookupS "_" . Global.last

setLast :: IORef Global -> SKI -> IO ()
setLast ref bird = do
    state <- ref.get
    let d = D{left=C "_", right=I, bird}
    IORef.modify Global.{last <- insertkv "_" d} ref    
            
cmdEval  ref   = cmdEvalWith ref eval
cmdStep  ref s = cmdEvalWith ref step s 
cmdParse ref   = cmdEvalWith ref id

cmdEvalWith :: IORef Global -> (SKI -> SKI) -> String -> IO ()
cmdEvalWith ref what "" = getLast ref >>= cmdEvalWith ref what . show
    
cmdEvalWith ref what reply = do
    t0 <- System.currentTimeMillis ()
    state <- ref.get  
    case parse reply of
            Left msg  -> stderr.println msg
            Right parsed -> do 
                let expr = subst state.last parsed
                case expr of
                    -- new definition
                    (App (App (C ":") left) right) -> do
                        case def state.birds left right of
                            Left s -> stderr.println ("ERROR: " ++ s)
                            Right d -> newdef ref d
                    -- 'a' elimination x
                    (App (App (C "\\") (V c)) x) -> do
                        let result = c `elimination` x
                        println result
                        setLast ref result
                        return ()
                    -- just eval
                    x   -> do
                        let result = what (subst state.birds x)
                        println (nice state.birds result)
                        setLast ref result
                        t1 <- System.currentTimeMillis ()
                        let dur = (t1-t0).double / 1000
                        when (dur > 1) do
                             stderr.println("Duration: " ++ show dur)
                -- return ()

newdef :: IORef Global -> Def -> IO ()
newdef ref d = do
    state <- ref.get
    let s = name d
        newbirds = case state.birds.lookupS s of
            Nothing -> state.birds.insert s d
            Just _  -> (fold remake Tree.empty  . replace d . deporder) state.birds
        remake :: DefTree -> Def -> DefTree
        remake tree d  = case def tree d.left d.right of
            Right d -> tree.insert (name d) d 
            Left  e -> tree
        replace d []  = []
        replace d (o:os)  
            | name o == name d = d : os
            | otherwise = o : replace d os 
    IORef.modify Global.{birds=newbirds} ref
    println (s ++ " = " ++ show d.bird)
    

cmdList :: IORef Global -> String -> IO ()
cmdList ref s = do
    state <- ref.get
    case parse s of
        Right (C s) -> case state.birds.lookupS s of
            Just def -> println (show def)
            Nothing  -> stderr.println("Bird " ++ s ++ " is unknown.")
        _ -> do
            mapM_ (println . show) (deporder state.birds) 

--- prints the last expression in raw form
cmdRaw :: IORef Global -> String -> IO ()
cmdRaw ref "" = getLast ref >>= println
cmdRaw ref s  = cmdParse ref s >> getLast ref >>= println
 
commands = [
    (´^step\s*´, cmdStep),
    (´^parse\s*´, cmdParse),
    (´^eval\s*´, cmdEval),
    (´^raw\s*´,  cmdRaw),
    (´^list\s*´, cmdList),
    (´^load\s*´,  loadFile),
    (´^save\s*´,  saveFile),
    ]

parseCommand "" = (cmdStep, "")
parseCommand s = try commands where
    try ((m,x):ms) 
        | s ~ m =  (x, (m.matcher s).replaceFirst "")
        | otherwise = try ms 
    try [] = (cmdEval, s) 

getReply :: IORef Global -> Maybe String -> IO String
getReply ref line = case line of
        -- Just "" -> do
        --     state <- ref.get
        --     return state.lastLine
        Just reply -> do
            state <- ref.get
--            ref.put state.{lastLine = reply}
            return reply
        Nothing -> throwIO (EOFException.new "EOF")


